// Generated by BUCKLESCRIPT VERSION 2.2.3, PLEASE EDIT WITH CARE
'use strict';

var Block = require("bs-platform/lib/js/block.js");
var Curry = require("bs-platform/lib/js/curry.js");
var Js_exn = require("bs-platform/lib/js/js_exn.js");
var Caml_obj = require("bs-platform/lib/js/caml_obj.js");
var Belt_Array = require("bs-platform/lib/js/belt_Array.js");
var Caml_format = require("bs-platform/lib/js/caml_format.js");
var Caml_exceptions = require("bs-platform/lib/js/caml_exceptions.js");
var Caml_builtin_exceptions = require("bs-platform/lib/js/caml_builtin_exceptions.js");

var substitutions = /* array */[
  /* tuple */[
    "@annually",
    "0 0 1 1 *"
  ],
  /* tuple */[
    "@monthly",
    "0 0 1 * *"
  ],
  /* tuple */[
    "@weekly",
    "0 0 * * 0"
  ],
  /* tuple */[
    "@daily",
    "0 0 * * *"
  ],
  /* tuple */[
    "@midnight",
    "0 0 * * *"
  ],
  /* tuple */[
    "@hourly",
    "0 * * * *"
  ]
];

function substitute(substitutions, str) {
  return Belt_Array.reduce(substitutions, str.toUpperCase(), (function (prevStr, param) {
                if (param[0] === str) {
                  return param[1];
                } else {
                  return prevStr;
                }
              }));
}

var __x = Belt_Array.range(1, 12);

var monthNames = Belt_Array.zip(/* array */[
      "JAN",
      "FEB",
      "MAR",
      "APR",
      "MAY",
      "JUN",
      "JUL",
      "AUG",
      "SEP",
      "OCT",
      "NOV",
      "DEC"
    ], Belt_Array.map(__x, (function (prim) {
            return String(prim);
          })));

var __x$1 = Belt_Array.range(0, 6);

var __x$2 = Belt_Array.zip(/* array */[
      "SUN",
      "MON",
      "TUE",
      "WED",
      "THU",
      "FRI",
      "SAT"
    ], Belt_Array.map(__x$1, (function (prim) {
            return String(prim);
          })));

var dayNames = Belt_Array.concat(__x$2, /* array */[/* tuple */[
        "7",
        "0"
      ]]);

var MalformedCronExpression = Caml_exceptions.create("CronExpression-NactPatterns.MalformedCronExpression");

function isNumber(str) {
  try {
    Caml_format.caml_int_of_string(str);
    return /* true */1;
  }
  catch (raw_exn){
    var exn = Js_exn.internalToOCamlException(raw_exn);
    if (exn[0] === Caml_builtin_exceptions.failure) {
      return /* false */0;
    } else {
      throw exn;
    }
  }
}

function toCommaSeparatedList(str, substitute) {
  var __x = str.split(",");
  return Belt_Array.map(__x, (function (i) {
                try {
                  return Caml_format.caml_int_of_string(Curry._1(substitute, i));
                }
                catch (raw_exn){
                  var exn = Js_exn.internalToOCamlException(raw_exn);
                  if (exn[0] === Caml_builtin_exceptions.failure) {
                    throw MalformedCronExpression;
                  } else {
                    throw exn;
                  }
                }
              }));
}

function parseToken(field, substitutions) {
  var substitute$1 = function (param) {
    return substitute(substitutions, param);
  };
  var match = field.split("-");
  var len = match.length;
  if (len >= 3) {
    throw MalformedCronExpression;
  } else {
    switch (len) {
      case 0 : 
          throw MalformedCronExpression;
      case 1 : 
          var n = match[0];
          if (n === "*") {
            return /* WildcardToken */0;
          } else if (isNumber(substitute(substitutions, n))) {
            return /* NumberToken */Block.__(2, [Caml_format.caml_int_of_string(substitute(substitutions, n))]);
          } else {
            return /* CommaSeparatedListToken */Block.__(1, [toCommaSeparatedList(n, substitute$1)]);
          }
      case 2 : 
          var start = match[0];
          var end_ = match[1];
          if (isNumber(substitute(substitutions, start)) && isNumber(substitute(substitutions, end_))) {
            return /* RangeToken */Block.__(0, [
                      Caml_format.caml_int_of_string(substitute(substitutions, start)),
                      Caml_format.caml_int_of_string(substitute(substitutions, end_))
                    ]);
          } else {
            throw MalformedCronExpression;
          }
      
    }
  }
}

function getIntervalToken(interval) {
  try {
    return Caml_format.caml_int_of_string(interval);
  }
  catch (raw_exn){
    var exn = Js_exn.internalToOCamlException(raw_exn);
    if (exn[0] === Caml_builtin_exceptions.failure) {
      throw MalformedCronExpression;
    } else {
      throw exn;
    }
  }
}

function inRange(start, end_, n) {
  if (Caml_obj.caml_lessequal(start, n)) {
    return Caml_obj.caml_lessequal(n, end_);
  } else {
    return /* false */0;
  }
}

function parseSubExpr(subExpr, start, end_, substitutions) {
  var match = subExpr.split("/");
  var len = match.length;
  var match$1;
  if (len >= 3) {
    throw MalformedCronExpression;
  } else {
    switch (len) {
      case 0 : 
          throw MalformedCronExpression;
      case 1 : 
          var field = match[0];
          match$1 = /* tuple */[
            parseToken(field, substitutions),
            /* None */0
          ];
          break;
      case 2 : 
          var field$1 = match[0];
          var interval = match[1];
          match$1 = /* tuple */[
            parseToken(field$1, substitutions),
            /* Some */[getIntervalToken(interval)]
          ];
          break;
      
    }
  }
  var intervalToken = match$1[1];
  var fieldToken = match$1[0];
  if (typeof fieldToken === "number") {
    if (intervalToken) {
      return /* `Values */[
              72054786,
              Belt_Array.rangeBy(start, end_, intervalToken[0])
            ];
    } else {
      return /* Wildcard */46765562;
    }
  } else {
    switch (fieldToken.tag | 0) {
      case 0 : 
          var b = fieldToken[1];
          var a = fieldToken[0];
          if (intervalToken) {
            return /* `Values */[
                    72054786,
                    Belt_Array.rangeBy(a, b, intervalToken[0])
                  ];
          } else {
            return /* `Values */[
                    72054786,
                    Belt_Array.range(a, b)
                  ];
          }
      case 1 : 
          var lst = fieldToken[0];
          if (intervalToken) {
            throw MalformedCronExpression;
          } else if (Belt_Array.every(lst, (function (param) {
                    return inRange(start, end_, param);
                  }))) {
            return /* `Values */[
                    72054786,
                    lst.sort()
                  ];
          } else {
            throw MalformedCronExpression;
          }
      case 2 : 
          var n = fieldToken[0];
          if (intervalToken) {
            if (n <= end_) {
              return /* `Values */[
                      72054786,
                      Belt_Array.rangeBy(n, end_, intervalToken[0])
                    ];
            } else {
              throw MalformedCronExpression;
            }
          } else if (inRange(start, end_, n)) {
            return /* `Values */[
                    72054786,
                    /* int array */[n]
                  ];
          } else {
            throw MalformedCronExpression;
          }
      
    }
  }
}

var spacesRegex = new RegExp("\\s+");

function parse(str) {
  var match = substitute(substitutions, str.trim()).split(spacesRegex);
  if (match.length !== 5) {
    throw MalformedCronExpression;
  } else {
    var minutes = match[0];
    var hours = match[1];
    var daysOfMonth = match[2];
    var months = match[3];
    var daysOfWeek = match[4];
    return /* record */[
            /* minutes */parseSubExpr(minutes, 0, 59, /* array */[]),
            /* hours */parseSubExpr(hours, 0, 23, /* array */[]),
            /* daysOfMonth */parseSubExpr(daysOfMonth, 1, 31, /* array */[]),
            /* months */parseSubExpr(months, 1, 12, monthNames),
            /* daysOfWeek */parseSubExpr(daysOfWeek, 0, 6, dayNames),
            /* expression */str
          ];
  }
}

exports.MalformedCronExpression = MalformedCronExpression;
exports.parse = parse;
/* monthNames Not a pure module */
