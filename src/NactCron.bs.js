// Generated by BUCKLESCRIPT VERSION 2.2.3, PLEASE EDIT WITH CARE
'use strict';

var Nact = require("reason-nact/src/Nact.js");
var Block = require("bs-platform/lib/js/block.js");
var Curry = require("bs-platform/lib/js/curry.js");
var Belt_List = require("bs-platform/lib/js/belt_List.js");
var Belt_Array = require("bs-platform/lib/js/belt_Array.js");
var Caml_int32 = require("bs-platform/lib/js/caml_int32.js");
var NactCron_Expression = require("./NactCron_Expression.bs.js");
var NactCron_Scheduling = require("./NactCron_Scheduling.bs.js");

function currentMinute() {
  return ((Date.now() | 0) / 1000 | 0) / 60 | 0;
}

function dateFromMinute(minute) {
  return new Date(Caml_int32.imul(Caml_int32.imul(minute, 1000), 60));
}

function $$setInterval$1(state, ctx) {
  if (state[/* interval */1]) {
    return state;
  } else {
    return /* record */[
            /* scheduleState */state[/* scheduleState */0],
            /* interval : Some */[setInterval((function () {
                      return Nact.Operators[/* <-< */0](ctx[/* self */2], /* DispatchPendingJobs */-611577581);
                    }), 30000)],
            /* lastMinute */state[/* lastMinute */2]
          ];
  }
}

function promiseReduce(arr, initialValue, f) {
  return Belt_Array.reduce(arr, Promise.resolve(initialValue), (function (prev, value) {
                return prev.then((function (prev) {
                              return Curry._2(f, prev, value);
                            }));
              }));
}

function make(parent, key) {
  return Nact.spawnPersistent(key, /* Some */[key], /* None */0, /* Some */[Caml_int32.imul(20, Nact.messages)], /* None */0, /* None */0, /* None */0, /* None */0, /* None */0, parent, (function (state, msg, ctx) {
                var state$1 = $$setInterval$1(state, ctx);
                if (typeof msg === "number") {
                  var state$2 = state$1;
                  var param = ctx;
                  var persist = param[/* persist */4];
                  var lastMinute = state$2[/* lastMinute */2];
                  var scheduleState = state$2[/* scheduleState */0];
                  var currentMinute$1 = currentMinute(/* () */0);
                  var match = +(lastMinute < 0);
                  var lastMinute$1 = match !== 0 ? currentMinute$1 - 1 | 0 : lastMinute;
                  if (currentMinute$1 > lastMinute$1) {
                    var scheduleState$1 = promiseReduce(Belt_Array.range(lastMinute$1, currentMinute$1), scheduleState, (function (state, minute) {
                            var state$1 = NactCron_Scheduling.update(state, NactCron_Scheduling.Time[/* fromDate */0](dateFromMinute(minute)));
                            var jobs = NactCron_Scheduling.getPendingJobs(scheduleState);
                            Belt_List.forEach(jobs, (function (param) {
                                    var match = param[2];
                                    return Nact.Operators[/* <-< */0](match[0], match[1]);
                                  }));
                            return Curry._1(persist, /* `ProcessedMinute */[
                                          1037758946,
                                          minute
                                        ]).then((function () {
                                          return Promise.resolve(state$1);
                                        }));
                          }));
                    return scheduleState$1.then((function (scheduleState) {
                                  return Promise.resolve(/* record */[
                                              /* scheduleState */scheduleState,
                                              /* interval */state$2[/* interval */1],
                                              /* lastMinute */state$2[/* lastMinute */2]
                                            ]);
                                }));
                  } else {
                    return Promise.resolve(state$2);
                  }
                } else {
                  var variant = msg[0];
                  if (variant !== -202624238) {
                    if (variant >= 991771725) {
                      if (variant >= 1037758946) {
                        return Promise.resolve(/* record */[
                                    /* scheduleState */state$1[/* scheduleState */0],
                                    /* interval */state$1[/* interval */1],
                                    /* lastMinute */msg[1]
                                  ]);
                      } else {
                        var state$3 = state$1;
                        var requestee = msg[1];
                        Nact.Operators[/* <-< */0](requestee, /* `ScheduledJobs */[
                              -17693053,
                              NactCron_Scheduling.getJobs(state$3[/* scheduleState */0])
                            ]);
                        return Promise.resolve(state$3);
                      }
                    } else if (variant >= 726695270) {
                      var match$1 = msg[1];
                      var state$4 = state$1;
                      var id = match$1[0];
                      var requestee$1 = match$1[1];
                      var match$2 = NactCron_Scheduling.tryFindJob(state$4[/* scheduleState */0], id);
                      if (match$2) {
                        Nact.Operators[/* <-< */0](requestee$1, /* `FoundScheduledJob */[
                              421824786,
                              match$2[0]
                            ]);
                      } else {
                        Nact.Operators[/* <-< */0](requestee$1, /* `ScheduledJobNotFound */[
                              -747017153,
                              id
                            ]);
                      }
                      return Promise.resolve(state$4);
                    } else {
                      var state$5 = state$1;
                      var param$1 = msg;
                      var param$2 = ctx;
                      var match$3 = param$1[1];
                      var requestee$2 = match$3[3];
                      var actor = match$3[2];
                      var msg$1 = match$3[1];
                      var expr = match$3[0];
                      var scheduleState$2 = state$5[/* scheduleState */0];
                      var parsedExpression;
                      try {
                        parsedExpression = /* Ok */Block.__(0, [NactCron_Expression.parse(expr)]);
                      }
                      catch (exn){
                        if (exn === NactCron_Expression.MalformedCronExpression) {
                          parsedExpression = /* Error */Block.__(1, [/* `MalformedCronExpression */[
                                647496001,
                                expr
                              ]]);
                        } else {
                          throw exn;
                        }
                      }
                      if (parsedExpression.tag) {
                        Nact.Operators[/* <-< */0](requestee$2, parsedExpression[0]);
                        return Promise.resolve(state$5);
                      } else {
                        var parsedExpr = parsedExpression[0];
                        return (
                                  param$2[/* recovering */6] !== 0 ? Promise.resolve(/* () */0) : Curry._1(param$2[/* persist */4], /* `StartScheduledJob */[
                                          -427054286,
                                          /* tuple */[
                                            expr,
                                            msg$1,
                                            actor,
                                            Nact.nobody(/* () */0)
                                          ]
                                        ])
                                ).then((function () {
                                      var match = NactCron_Scheduling.addJob(scheduleState$2, parsedExpr, /* tuple */[
                                            actor,
                                            msg$1
                                          ]);
                                      Nact.Operators[/* <-< */0](requestee$2, /* `ScheduledJobStarted */[
                                            -587316431,
                                            match[0][0]
                                          ]);
                                      return Promise.resolve(/* record */[
                                                  /* scheduleState */match[1],
                                                  /* interval */state$5[/* interval */1],
                                                  /* lastMinute */state$5[/* lastMinute */2]
                                                ]);
                                    }));
                      }
                    }
                  } else {
                    var match$4 = msg[1];
                    var state$6 = state$1;
                    var id$1 = match$4[0];
                    var requestee$3 = match$4[1];
                    var param$3 = ctx;
                    var scheduleState$3 = NactCron_Scheduling.removeJob(state$6[/* scheduleState */0], id$1);
                    Nact.Operators[/* <-< */0](requestee$3, /* `ScheduledJobStopped */[
                          -347804675,
                          id$1
                        ]);
                    return (
                              param$3[/* recovering */6] !== 0 ? Promise.resolve(/* () */0) : Curry._1(param$3[/* persist */4], /* `StopScheduledJob */[
                                      -202624238,
                                      /* tuple */[
                                        id$1,
                                        Nact.nobody(/* () */0)
                                      ]
                                    ])
                            ).then((function () {
                                  return Promise.resolve(/* record */[
                                              /* scheduleState */scheduleState$3,
                                              /* interval */state$6[/* interval */1],
                                              /* lastMinute */state$6[/* lastMinute */2]
                                            ]);
                                }));
                  }
                }
              }), /* record */[
              /* scheduleState */NactCron_Scheduling.empty,
              /* interval : None */0,
              /* lastMinute */-1
            ]);
}

var Scheduling = 0;

exports.Scheduling = Scheduling;
exports.make = make;
/* Nact Not a pure module */
