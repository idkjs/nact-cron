// Generated by BUCKLESCRIPT VERSION 2.2.3, PLEASE EDIT WITH CARE
'use strict';

var Jest = require("@glennsl/bs-jest/src/jest.js");
var Random = require("bs-platform/lib/js/random.js");
var Belt_List = require("bs-platform/lib/js/belt_List.js");
var NactCron_Expression = require("../src/NactCron_Expression.bs.js");
var NactCron_Scheduling = require("../src/NactCron_Scheduling.bs.js");

describe("update", (function () {
        Jest.test("The schedule state updated twice with the same time should still return the same schedule", (function () {
                var time = /* record */[
                  /* year */2022,
                  /* month */1,
                  /* dayOfMonth */2,
                  /* dayOfWeek */2,
                  /* hour */0,
                  /* minute */0,
                  /* daysInMonth */31
                ];
                return Jest.Expect[/* toHaveLength */13](1, Jest.Expect[/* expect */0](Belt_List.toArray(NactCron_Scheduling.getPendingJobs(NactCron_Scheduling.update(NactCron_Scheduling.update(NactCron_Scheduling.addJob(NactCron_Scheduling.empty, NactCron_Expression.parse("0 0 2 * *"), "job")[1], time), time)))));
              }));
        Jest.test("Should update schedules if the year changes", (function () {
                var time1 = /* record */[
                  /* year */2022,
                  /* month */1,
                  /* dayOfMonth */2,
                  /* dayOfWeek */2,
                  /* hour */0,
                  /* minute */0,
                  /* daysInMonth */31
                ];
                var newrecord = time1.slice();
                newrecord[/* year */0] = 2023;
                var match = NactCron_Scheduling.addJob(NactCron_Scheduling.addJob(NactCron_Scheduling.empty, NactCron_Expression.parse("* * * * * 2022"), "job")[1], NactCron_Expression.parse("* * * * * 2023"), "job");
                return Jest.Expect[/* toEqual */12](/* :: */[
                            match[0],
                            /* [] */0
                          ], Jest.Expect[/* expect */0](NactCron_Scheduling.getPendingJobs(NactCron_Scheduling.update(NactCron_Scheduling.update(match[1], time1), newrecord))));
              }));
        Jest.test("Should update schedules if the month changes", (function () {
                var time1 = /* record */[
                  /* year */2022,
                  /* month */1,
                  /* dayOfMonth */2,
                  /* dayOfWeek */2,
                  /* hour */0,
                  /* minute */0,
                  /* daysInMonth */31
                ];
                var newrecord = time1.slice();
                newrecord[/* month */1] = 2;
                var match = NactCron_Scheduling.addJob(NactCron_Scheduling.addJob(NactCron_Scheduling.empty, NactCron_Expression.parse("* * * JAN *"), "job")[1], NactCron_Expression.parse("* * * FEB *"), "job");
                return Jest.Expect[/* toEqual */12](/* :: */[
                            match[0],
                            /* [] */0
                          ], Jest.Expect[/* expect */0](NactCron_Scheduling.getPendingJobs(NactCron_Scheduling.update(NactCron_Scheduling.update(match[1], time1), newrecord))));
              }));
        Jest.test("Should update schedules if the day of month changes", (function () {
                var time2 = /* record */[
                  /* year */2022,
                  /* month */1,
                  /* dayOfMonth */3,
                  /* dayOfWeek */3,
                  /* hour */0,
                  /* minute */0,
                  /* daysInMonth */31
                ];
                var match = NactCron_Scheduling.addJob(NactCron_Scheduling.addJob(NactCron_Scheduling.empty, NactCron_Expression.parse("* * 2 * *"), "job")[1], NactCron_Expression.parse("* * 3 * *"), "job");
                return Jest.Expect[/* toEqual */12](/* :: */[
                            match[0],
                            /* [] */0
                          ], Jest.Expect[/* expect */0](NactCron_Scheduling.getPendingJobs(NactCron_Scheduling.update(NactCron_Scheduling.update(match[1], /* record */[
                                            /* year */2022,
                                            /* month */1,
                                            /* dayOfMonth */2,
                                            /* dayOfWeek */2,
                                            /* hour */0,
                                            /* minute */0,
                                            /* daysInMonth */31
                                          ]), time2))));
              }));
        Jest.test("Should update schedules if the hour changes", (function () {
                var time1 = /* record */[
                  /* year */2022,
                  /* month */1,
                  /* dayOfMonth */2,
                  /* dayOfWeek */2,
                  /* hour */2,
                  /* minute */0,
                  /* daysInMonth */31
                ];
                var newrecord = time1.slice();
                newrecord[/* hour */4] = 3;
                var match = NactCron_Scheduling.addJob(NactCron_Scheduling.addJob(NactCron_Scheduling.empty, NactCron_Expression.parse("* 2 * * *"), "job")[1], NactCron_Expression.parse("* 3 * * *"), "job");
                return Jest.Expect[/* toEqual */12](/* :: */[
                            match[0],
                            /* [] */0
                          ], Jest.Expect[/* expect */0](NactCron_Scheduling.getPendingJobs(NactCron_Scheduling.update(NactCron_Scheduling.update(match[1], time1), newrecord))));
              }));
        return Jest.test("Should update schedules if the minute changes", (function () {
                      var time1 = /* record */[
                        /* year */2022,
                        /* month */1,
                        /* dayOfMonth */2,
                        /* dayOfWeek */2,
                        /* hour */2,
                        /* minute */0,
                        /* daysInMonth */31
                      ];
                      var newrecord = time1.slice();
                      newrecord[/* minute */5] = 1;
                      var match = NactCron_Scheduling.addJob(NactCron_Scheduling.empty, NactCron_Expression.parse("1 * * * *"), "job");
                      return Jest.Expect[/* toEqual */12](/* :: */[
                                  match[0],
                                  /* [] */0
                                ], Jest.Expect[/* expect */0](NactCron_Scheduling.getPendingJobs(NactCron_Scheduling.update(NactCron_Scheduling.update(match[1], time1), newrecord))));
                    }));
      }));

describe("getJobs", (function () {
        return Jest.test("All schedules should be returned (including non matching ones)", (function () {
                      return Jest.Expect[/* toHaveLength */13](2, Jest.Expect[/* expect */0](Belt_List.toArray(NactCron_Scheduling.getJobs(NactCron_Scheduling.addJob(NactCron_Scheduling.addJob(NactCron_Scheduling.update(NactCron_Scheduling.empty, /* record */[
                                                              /* year */2022,
                                                              /* month */1,
                                                              /* dayOfMonth */2,
                                                              /* dayOfWeek */2,
                                                              /* hour */0,
                                                              /* minute */0,
                                                              /* daysInMonth */31
                                                            ]), NactCron_Expression.parse("0 0 1 * *"), "job")[1], NactCron_Expression.parse("0 0 * * TUE"), "job2")[1]))));
                    }));
      }));

describe("tryFindJob", (function () {
        var initialState = NactCron_Scheduling.update(NactCron_Scheduling.empty, /* record */[
              /* year */2022,
              /* month */1,
              /* dayOfMonth */2,
              /* dayOfWeek */2,
              /* hour */2,
              /* minute */0,
              /* daysInMonth */31
            ]);
        Jest.test("Trying to find an existing schedule should return Some", (function () {
                var match = NactCron_Scheduling.addJob(initialState, NactCron_Expression.parse("* * * * * 2023"), "job");
                var schedule = match[0];
                return Jest.Expect[/* toEqual */12](/* Some */[schedule], Jest.Expect[/* expect */0](NactCron_Scheduling.tryFindJob(match[1], schedule[0])));
              }));
        Jest.test("Trying to find an existing schedule should return Some", (function () {
                var match = NactCron_Scheduling.addJob(initialState, NactCron_Expression.parse("* * * 2 *"), "job");
                var schedule = match[0];
                return Jest.Expect[/* toEqual */12](/* Some */[schedule], Jest.Expect[/* expect */0](NactCron_Scheduling.tryFindJob(match[1], schedule[0])));
              }));
        Jest.test("Trying to find an existing schedule should return Some", (function () {
                var match = NactCron_Scheduling.addJob(initialState, NactCron_Expression.parse("* * * * 1"), "job");
                var schedule = match[0];
                return Jest.Expect[/* toEqual */12](/* Some */[schedule], Jest.Expect[/* expect */0](NactCron_Scheduling.tryFindJob(match[1], schedule[0])));
              }));
        Jest.test("Trying to find an existing schedule should return Some", (function () {
                var match = NactCron_Scheduling.addJob(initialState, NactCron_Expression.parse("* * 1 * *"), "job");
                var schedule = match[0];
                return Jest.Expect[/* toEqual */12](/* Some */[schedule], Jest.Expect[/* expect */0](NactCron_Scheduling.tryFindJob(match[1], schedule[0])));
              }));
        Jest.test("Trying to find an existing schedule should return Some", (function () {
                var match = NactCron_Scheduling.addJob(initialState, NactCron_Expression.parse("* 3 * * *"), "job");
                var schedule = match[0];
                return Jest.Expect[/* toEqual */12](/* Some */[schedule], Jest.Expect[/* expect */0](NactCron_Scheduling.tryFindJob(match[1], schedule[0])));
              }));
        Jest.test("Trying to find an existing schedule should return Some", (function () {
                var match = NactCron_Scheduling.addJob(initialState, NactCron_Expression.parse("1 * * * *"), "job");
                var schedule = match[0];
                return Jest.Expect[/* toEqual */12](/* Some */[schedule], Jest.Expect[/* expect */0](NactCron_Scheduling.tryFindJob(match[1], schedule[0])));
              }));
        Jest.test("Trying to find an existing schedule should return Some", (function () {
                var match = NactCron_Scheduling.addJob(initialState, NactCron_Expression.parse("* * * * *"), "job");
                var schedule = match[0];
                return Jest.Expect[/* toEqual */12](/* Some */[schedule], Jest.Expect[/* expect */0](NactCron_Scheduling.tryFindJob(match[1], schedule[0])));
              }));
        return Jest.test("Trying to find a non existant schedule should return None", (function () {
                      var state = NactCron_Scheduling.addJob(initialState, NactCron_Expression.parse("1 2 2 1 * 2022"), "job")[1];
                      return Jest.Expect[/* toEqual */12](/* None */0, Jest.Expect[/* expect */0](NactCron_Scheduling.tryFindJob(state, NactCron_Scheduling.ScheduleId[/* fromInteger */0](Random.$$int(1000)))));
                    }));
      }));

describe("removeJob", (function () {
        Jest.test("Trying to remove a job which never even existed should return successfully with the previous state", (function () {
                var state = NactCron_Scheduling.addJob(NactCron_Scheduling.update(NactCron_Scheduling.empty, /* record */[
                            /* year */2022,
                            /* month */1,
                            /* dayOfMonth */2,
                            /* dayOfWeek */2,
                            /* hour */0,
                            /* minute */0,
                            /* daysInMonth */31
                          ]), NactCron_Expression.parse("0 0 1 * *"), "job")[1];
                return Jest.Expect[/* toEqual */12](state, Jest.Expect[/* expect */0](NactCron_Scheduling.removeJob(state, NactCron_Scheduling.ScheduleId[/* fromInteger */0](Random.$$int(1000)))));
              }));
        var time = /* record */[
          /* year */2022,
          /* month */2,
          /* dayOfMonth */2,
          /* dayOfWeek */2,
          /* hour */2,
          /* minute */0,
          /* daysInMonth */31
        ];
        var initialState = NactCron_Scheduling.update(NactCron_Scheduling.empty, time);
        Jest.test("Removing a job should successfully remove the job", (function () {
                var match = NactCron_Scheduling.addJob(NactCron_Scheduling.update(NactCron_Scheduling.empty, time), NactCron_Expression.parse("* * * * * 2023"), "job");
                return Jest.Expect[/* toEqual */12](initialState, Jest.Expect[/* expect */0](NactCron_Scheduling.removeJob(match[1], match[0][0])));
              }));
        Jest.test("Removing a job should successfully remove the job", (function () {
                var match = NactCron_Scheduling.addJob(NactCron_Scheduling.update(NactCron_Scheduling.empty, time), NactCron_Expression.parse("* * * 1 *"), "job");
                return Jest.Expect[/* toEqual */12](initialState, Jest.Expect[/* expect */0](NactCron_Scheduling.removeJob(match[1], match[0][0])));
              }));
        Jest.test("Removing a job should successfully remove the job", (function () {
                var match = NactCron_Scheduling.addJob(NactCron_Scheduling.update(NactCron_Scheduling.empty, time), NactCron_Expression.parse("* * * * 1"), "job");
                return Jest.Expect[/* toEqual */12](initialState, Jest.Expect[/* expect */0](NactCron_Scheduling.removeJob(match[1], match[0][0])));
              }));
        Jest.test("Removing a job should successfully remove the job", (function () {
                var match = NactCron_Scheduling.addJob(NactCron_Scheduling.update(NactCron_Scheduling.empty, time), NactCron_Expression.parse("* * 1 * *"), "job");
                return Jest.Expect[/* toEqual */12](initialState, Jest.Expect[/* expect */0](NactCron_Scheduling.removeJob(match[1], match[0][0])));
              }));
        Jest.test("Removing a job should successfully remove the job", (function () {
                var match = NactCron_Scheduling.addJob(NactCron_Scheduling.update(NactCron_Scheduling.empty, time), NactCron_Expression.parse("* 1 * * *"), "job");
                return Jest.Expect[/* toEqual */12](initialState, Jest.Expect[/* expect */0](NactCron_Scheduling.removeJob(match[1], match[0][0])));
              }));
        Jest.test("Removing a job should successfully remove the job", (function () {
                var match = NactCron_Scheduling.addJob(NactCron_Scheduling.update(NactCron_Scheduling.empty, time), NactCron_Expression.parse("1 * * * *"), "job");
                return Jest.Expect[/* toEqual */12](initialState, Jest.Expect[/* expect */0](NactCron_Scheduling.removeJob(match[1], match[0][0])));
              }));
        return Jest.test("Removing a job should successfully remove the job", (function () {
                      var match = NactCron_Scheduling.addJob(NactCron_Scheduling.update(NactCron_Scheduling.empty, time), NactCron_Expression.parse("* * * * *"), "job");
                      return Jest.Expect[/* toEqual */12](initialState, Jest.Expect[/* expect */0](NactCron_Scheduling.removeJob(match[1], match[0][0])));
                    }));
      }));

describe("getPendingJobs", (function () {
        Jest.test("An all wildcard schedule should always be returned", (function () {
                return Jest.Expect[/* toHaveLength */13](1, Jest.Expect[/* expect */0](Belt_List.toArray(NactCron_Scheduling.getPendingJobs(NactCron_Scheduling.addJob(NactCron_Scheduling.update(NactCron_Scheduling.empty, NactCron_Scheduling.Time[/* fromDate */0](new Date())), NactCron_Expression.parse("* * * * *"), "job")[1]))));
              }));
        return Jest.test("A non matching schedule should not be returned", (function () {
                      return Jest.Expect[/* toHaveLength */13](1, Jest.Expect[/* expect */0](Belt_List.toArray(NactCron_Scheduling.getPendingJobs(NactCron_Scheduling.addJob(NactCron_Scheduling.addJob(NactCron_Scheduling.update(NactCron_Scheduling.empty, /* record */[
                                                              /* year */2022,
                                                              /* month */1,
                                                              /* dayOfMonth */2,
                                                              /* dayOfWeek */2,
                                                              /* hour */0,
                                                              /* minute */0,
                                                              /* daysInMonth */31
                                                            ]), NactCron_Expression.parse("0 0 1 * *"), "job")[1], NactCron_Expression.parse("0 0 * * TUE"), "job2")[1]))));
                    }));
      }));

describe("addJob", (function () {
        var initialState = NactCron_Scheduling.update(NactCron_Scheduling.empty, /* record */[
              /* year */2022,
              /* month */1,
              /* dayOfMonth */2,
              /* dayOfWeek */2,
              /* hour */2,
              /* minute */1,
              /* daysInMonth */31
            ]);
        return Jest.test("A new job should be sucessfully added ", (function () {
                      var match = NactCron_Scheduling.addJob(initialState, NactCron_Expression.parse("10 * * * *"), "job");
                      return Jest.Expect[/* toEqual */12](/* :: */[
                                  match[0],
                                  /* [] */0
                                ], Jest.Expect[/* expect */0](NactCron_Scheduling.getJobs(match[1])));
                    }));
      }));

var Expression = 0;

exports.Expression = Expression;
/*  Not a pure module */
